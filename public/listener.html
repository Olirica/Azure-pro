<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Simo by Cano√´ ¬∑ Listener</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <style>
      :root {
        color-scheme: light dark;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        line-height: 1.5;
      }
      body {
        margin: 0;
        padding: 1.5rem;
        background: #020617;
        color: #e2e8f0;
      }
      main {
        max-width: 960px;
        margin: 0 auto;
      }
      section {
        background: rgba(2, 6, 23, 0.75);
        border-radius: 12px;
        padding: 1.5rem;
        margin-bottom: 1.5rem;
        border: 1px solid rgba(148, 163, 184, 0.2);
        box-shadow: 0 20px 35px -30px rgba(2, 132, 199, 0.8);
      }
      h1,
      h2 {
        margin-top: 0;
      }
      label {
        display: block;
        margin-top: 0.75rem;
        font-weight: 600;
      }
      input,
      select {
        width: 100%;
        padding: 0.65rem 0.8rem;
        margin-top: 0.35rem;
        border-radius: 8px;
        border: 1px solid rgba(148, 163, 184, 0.3);
        background: rgba(2, 6, 23, 0.45);
        color: inherit;
      }
      button {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.65rem 1.1rem;
        border-radius: 8px;
        border: none;
        font-weight: 600;
        cursor: pointer;
        margin-right: 1rem;
        background: #38bdf8;
        color: #0f172a;
        transition: transform 120ms ease, box-shadow 120ms ease;
      }
      button[disabled] {
        opacity: 0.6;
        cursor: not-allowed;
      }
      button:hover:not([disabled]) {
        transform: translateY(-1px);
        box-shadow: 0 12px 18px -12px rgba(56, 189, 248, 0.9);
      }
      ul {
        list-style: none;
        padding: 0;
        margin: 0;
      }
      li {
        padding: 0.75rem 1rem;
        margin-bottom: 0.55rem;
        border-radius: 10px;
        border: 1px solid rgba(148, 163, 184, 0.25);
        background: rgba(15, 23, 42, 0.45);
        transition: background 180ms ease, border-color 180ms ease;
      }
      li[data-stage="soft"] {
        border-color: rgba(94, 234, 212, 0.25);
        background: rgba(22, 78, 99, 0.35);
      }
      li[data-stage="hard"] {
        border-color: rgba(147, 197, 253, 0.5);
        background: rgba(59, 130, 246, 0.18);
      }
      .stack {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        align-items: center;
      }
      .stack > div {
        min-width: 200px;
        flex: 1 1 220px;
      }
      .status {
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        font-size: 0.95rem;
      }
      .badge {
        padding: 0.15rem 0.55rem;
        border-radius: 999px;
        font-size: 0.75rem;
        text-transform: uppercase;
        letter-spacing: 0.07em;
        background: rgba(56, 189, 248, 0.2);
        border: 1px solid rgba(56, 189, 248, 0.4);
      }
      .controls {
        display: flex;
        align-items: center;
        flex-wrap: wrap;
        gap: 1rem;
        margin-top: 1.25rem;
      }
      label.checkbox {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
      }
      label.checkbox input {
        width: auto;
        margin: 0;
      }
      small {
        color: rgba(148, 163, 184, 0.75);
      }
      /* Translation quality indicators (dev mode) */
      .segment {
        display: inline;
      }
      .quality-badge {
        font-size: 0.85em;
        margin-right: 0.2rem;
        cursor: help;
      }
      .quality-alert .translation {
        background: rgba(239, 68, 68, 0.2);
        padding: 0.1rem 0.3rem;
        border-radius: 4px;
      }
      .quality-warning .translation {
        background: rgba(250, 204, 21, 0.2);
        padding: 0.1rem 0.3rem;
        border-radius: 4px;
      }
    </style>
  </head>
  <body>
    <main>
      <section>
        <h1>Listener Console</h1>
        <p>
          Connects to the Node server via WebSocket, replaces each sentence in-place, and optionally
          plays Text-to-Speech for hard finals.
        </p>
        <div class="stack">
          <div>
            <label for="roomId">Room ID</label>
            <input id="roomId" type="text" value="demo-room" />
          </div>
          <div>
            <label for="targetLang">Language</label>
            <select id="targetLang">
              <option value="fr-CA" selected>French (Canada)</option>
              <option value="fr-FR">French (France)</option>
              <option value="en-US">English (US)</option>
              <option value="en-CA">English (Canada)</option>
              <option value="es-ES">Spanish (Spain)</option>
              <option value="es-MX">Spanish (Mexico)</option>
            </select>
          </div>
        </div>
        <div class="controls">
          <div class="status">
            <span class="badge" id="connectionStatus">Disconnected</span>
            <span id="queueStats">‚Äî</span>
          </div>
          <label class="checkbox">
            <input type="checkbox" id="ttsToggle" checked />
            Enable TTS
          </label>
          <button id="connectBtn">Connect</button>
          <button id="disconnectBtn" disabled>Disconnect</button>
        </div>
      </section>

      <section>
        <h2>Transcript</h2>
        <ul id="transcript"></ul>
      </section>

      <section>
        <h2>Now Playing</h2>
        <p id="nowPlaying">Nothing queued.</p>
        <small>Audio plays only for hard (final) patches.</small>
      </section>
    </main>

    <script>
      (() => {
        // Check for dev mode URL parameter (?dev=true)
        const urlParams = new URLSearchParams(window.location.search);
        const isDevMode = urlParams.get('dev') === 'true';

        const transcriptEl = document.getElementById('transcript');
        const connectionStatus = document.getElementById('connectionStatus');
        const queueStats = document.getElementById('queueStats');
        const nowPlayingEl = document.getElementById('nowPlaying');
        const connectBtn = document.getElementById('connectBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const ttsToggle = document.getElementById('ttsToggle');

        const WS_READY = 1;

        const state = {
          ws: null,
          roomId: 'demo-room',
          lang: 'fr-FR',
          wantsTts: true,
          itemsByUnit: new Map(),
          queue: [],
          playing: null,
          shouldReconnect: false,
          reconnectDelay: 2000,
          reconnectTimer: null,
          devMode: isDevMode
        };

        function parseInputs() {
          state.roomId = document.getElementById('roomId').value.trim() || 'demo-room';
        state.lang = document.getElementById('targetLang').value.trim() || 'fr-CA';
          state.wantsTts = ttsToggle.checked;
        }

        function setStatus(text) {
          connectionStatus.textContent = text;
        }

        function setQueueStats(text) {
          queueStats.textContent = text;
        }

        function renderPatch(patch) {
          // Support both old unitId and new utteranceId formats
          const utterId = patch.utteranceId || patch.unitId;
          if (!utterId) {
            return;
          }

          const now = Date.now();
          const receivedAt = now;
          const rev = patch.rev ?? patch.version ?? 0;
          const isFinal = patch.isFinal ?? (patch.stage === 'hard');
          const isRevision = patch.op === 'translation-revision';

          // Hide soft/partial patches (they'll update in-place when final arrives)
          if (!isFinal && !isRevision) {
            console.debug('[listener] Soft patch (hidden)', {
              utteranceId: utterId,
              text: patch.text?.substring(0, 40),
              rev,
              receivedAt
            });
            return;
          }

          // Handle suppress patches (segments merged into previous)
          if (patch.op === 'suppress') {
            console.debug('[listener] Suppress patch (hiding segment merged into previous)', {
              utteranceId: utterId,
              mergedIntoPrevious: patch.mergedIntoPrevious,
              suppressReason: patch.suppressReason
            });

            // Check if this segment was already rendered
            const existing = state.itemsByUnit.get(utterId);
            if (existing && existing.element) {
              // Reconstruct the paragraph to remove this segment
              const paragraph = existing.element;
              if (paragraph && paragraph.dataset.utterances) {
                const utteranceIds = JSON.parse(paragraph.dataset.utterances);
                const texts = utteranceIds
                  .map(id => {
                    // Skip the suppressed utterance
                    if (id === utterId) return '';
                    const item = state.itemsByUnit.get(id);
                    if (item?.suppressed) return '';
                    return item?.text || '';
                  })
                  .filter(Boolean);

                // Capitalize first letter of paragraph
                if (texts.length > 0) {
                  texts[0] = texts[0].charAt(0).toUpperCase() + texts[0].slice(1);
                }

                paragraph.textContent = texts.join(' ');

                console.debug('[listener] Suppressed segment removed from paragraph', {
                  utteranceId: utterId,
                  paragraphLength: paragraph.textContent.length
                });
              }
            }

            // Mark this utterance as suppressed
            state.itemsByUnit.set(utterId, {
              text: '',
              rev,
              receivedAt,
              element: existing?.element || null,
              suppressed: true,
              mergedIntoPrevious: patch.mergedIntoPrevious
            });

            return;
          }

          // Handle translation revisions (backward peek gender corrections + continuation merges)
          if (isRevision) {
            const existing = state.itemsByUnit.get(utterId);
            if (!existing) {
              console.debug('[listener] Revision for unknown utterance (ignoring)', {
                utteranceId: utterId,
                text: patch.text?.substring(0, 40)
              });
              return;
            }

            // Update stored text with revision
            existing.text = patch.text;
            existing.rev = rev;
            existing.receivedAt = receivedAt;

            // Reconstruct the paragraph containing this utterance
            const paragraph = existing.element;
            if (paragraph && paragraph.dataset.utterances) {
              const utteranceIds = JSON.parse(paragraph.dataset.utterances);
              const texts = utteranceIds
                .map(id => {
                  const item = state.itemsByUnit.get(id);
                  // Skip suppressed segments
                  if (item?.suppressed) return '';
                  return item?.text || '';
                })
                .filter(Boolean);

              // Capitalize first letter of paragraph
              if (texts.length > 0) {
                texts[0] = texts[0].charAt(0).toUpperCase() + texts[0].slice(1);
              }

              paragraph.textContent = texts.join(' ');

              console.debug('[listener] Revision applied (paragraph reconstructed)', {
                utteranceId: utterId,
                newText: patch.text?.substring(0, 50),
                revisionReason: patch.revisionReason,
                revisionGender: patch.revisionGender,
                mergedWith: patch.mergedWith,
                paragraphLength: paragraph.textContent.length
              });
            }

            return;
          }

          // Check if we've already rendered this utterance (prevent duplicates)
          if (state.itemsByUnit.has(utterId)) {
            const existing = state.itemsByUnit.get(utterId);

            // Skip if already suppressed (merged into previous segment)
            if (existing.suppressed) {
              console.debug('[listener] Skipping suppressed utterance', {
                utteranceId: utterId,
                mergedIntoPrevious: existing.mergedIntoPrevious
              });
              return;
            }

            if (existing.rev != null && rev <= existing.rev) {
              console.debug('[listener] Skipping stale/duplicate revision', {
                utteranceId: utterId,
                currentRev: existing.rev,
                incomingRev: rev
              });
              return;
            }
          }

          // Get or create the current paragraph
          let currentParagraph = transcriptEl.lastElementChild;

          // Create new paragraph if none exists or if this is a new speaking session
          // (detect pause by checking if last update was > 5 seconds ago)
          const lastUpdate = currentParagraph?.dataset.lastUpdate ? parseInt(currentParagraph.dataset.lastUpdate) : 0;
          const timeSinceLastUpdate = now - lastUpdate;

          if (!currentParagraph || timeSinceLastUpdate > 5000) {
            currentParagraph = document.createElement('li');
            currentParagraph.dataset.lastUpdate = now;
            currentParagraph.dataset.stage = 'hard';
            currentParagraph.dataset.utterances = '[]'; // Track utterances in this paragraph
            transcriptEl.appendChild(currentParagraph);
          } else {
            currentParagraph.dataset.lastUpdate = now;
          }

          // Track utterances in this paragraph
          const utteranceIds = currentParagraph.dataset.utterances
            ? JSON.parse(currentParagraph.dataset.utterances)
            : [];
          utteranceIds.push(utterId);
          currentParagraph.dataset.utterances = JSON.stringify(utteranceIds);

          // Append text with space separator
          const currentText = currentParagraph.textContent;
          let textToAppend = patch.text;

          // Capitalize first letter if this is the start of a paragraph
          if (!currentText && textToAppend) {
            textToAppend = textToAppend.charAt(0).toUpperCase() + textToAppend.slice(1);
          }

          // Dev mode: Show translation quality indicators
          if (state.devMode) {
            // Get quality score based on length ratio
            let qualityIndicator = '';
            let qualityClass = '';
            if (patch.lengthRatio > 3.0) {
              qualityIndicator = 'üî¥'; // Likely hallucination
              qualityClass = 'quality-alert';
            } else if (patch.lengthRatio > 2.0) {
              qualityIndicator = 'üü°'; // Warning - possible additions
              qualityClass = 'quality-warning';
            } else {
              qualityIndicator = 'üü¢'; // Normal
              qualityClass = 'quality-ok';
            }

            // Add incomplete indicator
            if (patch.isIncomplete) {
              qualityIndicator += '‚ö†Ô∏è';
            }

            // Create segment with metadata
            const segment = document.createElement('span');
            segment.className = `segment ${qualityClass}`;
            segment.innerHTML = `<span class="quality-badge" title="Length ratio: ${patch.lengthRatio?.toFixed(2) || 'N/A'}">${qualityIndicator}</span> <span class="translation">${textToAppend}</span>`;

            // Add source text tooltip in dev mode
            if (patch.sourceText) {
              segment.title = `Source: ${patch.sourceText}\nProvider: ${patch.provider || 'N/A'}\nRatio: ${patch.lengthRatio?.toFixed(2) || 'N/A'}`;
            }

            // Append to paragraph
            if (currentText) {
              currentParagraph.appendChild(document.createTextNode(' '));
            }
            currentParagraph.appendChild(segment);
          } else {
            // Production mode: Simple text only
            currentParagraph.textContent = currentText
              ? `${currentText} ${textToAppend}`
              : textToAppend;
          }

          // Track this utterance to prevent duplicates
          state.itemsByUnit.set(utterId, {
            rev,
            text: patch.text, // Store original text for revisions
            element: currentParagraph,
            receivedAt,
            isFinal
          });

          console.debug('[listener] Patch appended to paragraph', {
            utteranceId: utterId,
            text: patch.text?.substring(0, 50),
            paragraphLength: currentParagraph.textContent.length,
            rev,
            isFinal,
            receivedAt
          });

          // Cleanup old paragraphs to prevent browser slowdown
          cleanupOldParagraphs();
        }

        function cleanupOldParagraphs() {
          const MAX_PARAGRAPHS = 20; // Keep last 20 paragraphs (live streaming focus)
          const paragraphs = transcriptEl.querySelectorAll('li');

          if (paragraphs.length > MAX_PARAGRAPHS) {
            const removeCount = paragraphs.length - MAX_PARAGRAPHS;
            for (let i = 0; i < removeCount; i++) {
              paragraphs[i].remove();
            }
            console.debug('[listener] Cleaned up old paragraphs', {
              removed: removeCount,
              remaining: MAX_PARAGRAPHS
            });
          }
        }

        /**
         * Parse unitId into components for sorting
         * Format: session|lang|index or session|lang|index#segment
         * Returns: { session, lang, index, segment }
         */
        function parseUnitId(unitId) {
          const parts = unitId.split('|');
          if (parts.length < 3) {
            return { session: '', lang: '', index: 0, segment: 0 };
          }
          const lastPart = parts[parts.length - 1];
          const segmentMatch = lastPart.match(/^(\d+)#(\d+)$/);
          if (segmentMatch) {
            return {
              session: parts.slice(0, -2).join('|'),
              lang: parts[parts.length - 2],
              index: parseInt(segmentMatch[1], 10),
              segment: parseInt(segmentMatch[2], 10)
            };
          }
          return {
            session: parts.slice(0, -2).join('|'),
            lang: parts[parts.length - 2],
            index: parseInt(parts[parts.length - 1], 10) || 0,
            segment: 0
          };
        }

        /**
         * Compare two unitIds for sorting
         * Returns: negative if a < b, positive if a > b, 0 if equal
         */
        function compareUnitIds(a, b) {
          const parsedA = parseUnitId(a);
          const parsedB = parseUnitId(b);

          // Compare session
          if (parsedA.session !== parsedB.session) {
            return parsedA.session.localeCompare(parsedB.session);
          }

          // Compare language
          if (parsedA.lang !== parsedB.lang) {
            return parsedA.lang.localeCompare(parsedB.lang);
          }

          // Compare index
          if (parsedA.index !== parsedB.index) {
            return parsedA.index - parsedB.index;
          }

          // Compare segment
          return parsedA.segment - parsedB.segment;
        }

        function enqueueTts(payload) {
          if (!state.wantsTts) {
            return;
          }
          const { unitId, rootUnitId, audio, text } = payload;
          if (!unitId || !audio) {
            return;
          }

          const calculatedRootUnitId = rootUnitId || unitId.split('#')[0];

          // Deduplicate: Remove any existing items with the same rootUnitId or unitId
          // This prevents duplicate/revised segments from playing
          const beforeLength = state.queue.length;
          state.queue = state.queue.filter(
            (item) => item.rootUnitId !== calculatedRootUnitId && item.unitId !== unitId
          );
          const removedCount = beforeLength - state.queue.length;

          // Cancel currently playing audio if it matches this rootUnitId
          if (state.playing &&
              (state.playing.rootUnitId === calculatedRootUnitId || state.playing.unitId === unitId)) {
            console.debug('[listener] Cancelling currently playing audio (replaced)', {
              oldUnitId: state.playing.unitId,
              newUnitId: unitId
            });
            state.playing.audio.pause();
            state.playing = null;
          }

          const audioUrl = `data:${payload.format || 'audio/wav'};base64,${audio}`;
          const queueItem = {
            unitId,
            rootUnitId: calculatedRootUnitId,
            audioUrl,
            text: text || '',
            enqueuedAt: Date.now()
          };

          state.queue.push(queueItem);

          // Sort queue by unitId to ensure correct playback order
          // This handles out-of-order network arrivals
          state.queue.sort((a, b) => compareUnitIds(a.unitId, b.unitId));

          const queueSize = state.queue.length + (state.playing ? 1 : 0);
          setQueueStats(`${queueSize} item(s) queued`);
          console.debug('[listener] TTS enqueued', {
            unitId,
            rootUnitId: calculatedRootUnitId,
            text: text?.substring(0, 40),
            queueSize,
            removed: removedCount,
            sorted: true
          });

          if (!state.playing) {
            playNext();
          }
        }

        function playNext() {
          if (!state.queue.length) {
            state.playing = null;
            nowPlayingEl.textContent = 'Nothing queued.';
            setQueueStats('Queue empty');
            console.debug('[listener] TTS queue empty');
            return;
          }

          const next = state.queue.shift();
          const now = Date.now();
          const queueLatency = now - next.enqueuedAt;

          const audio = new Audio(next.audioUrl);
          state.playing = {
            unitId: next.unitId,
            rootUnitId: next.rootUnitId || next.unitId.split('|').slice(0, -1).join('|'),
            audio,
            startedAt: now
          };
          nowPlayingEl.textContent = `Playing #${next.unitId.split('|').pop()}: ${next.text}`;

          console.debug('[listener] TTS playback started', {
            unitId: next.unitId,
            text: next.text?.substring(0, 40),
            queueLatencyMs: queueLatency,
            remainingInQueue: state.queue.length
          });

          audio.onended = () => {
            const playDuration = Date.now() - state.playing.startedAt;
            console.debug('[listener] TTS playback ended', {
              unitId: next.unitId,
              playDurationMs: playDuration,
              remainingInQueue: state.queue.length
            });
            state.playing = null;
            playNext();
          };
          audio.onerror = (err) => {
            console.error('[listener] TTS playback error', {
              unitId: next.unitId,
              error: err
            });
            state.playing = null;
            nowPlayingEl.textContent = 'Playback error.';
            playNext();
          };
          audio.play().catch((err) => {
            console.warn('[listener] Playback blocked (autoplay policy)', {
              unitId: next.unitId,
              error: err.message
            });
            state.playing = null;
            nowPlayingEl.textContent = 'Playback blocked (user gesture required).';
          });
          setQueueStats(`${state.queue.length + 1} item(s) queued`);
        }

        function scheduleReconnect() {
          if (!state.shouldReconnect) {
            return;
          }
          if (state.reconnectTimer) {
            return;
          }
          setStatus('Reconnecting‚Ä¶');
          state.reconnectTimer = setTimeout(() => {
            state.reconnectTimer = null;
            connect(true);
          }, state.reconnectDelay);
        }

        function connect(isRetry = false) {
          parseInputs();
          if (state.ws && state.ws.readyState === WS_READY) {
            state.ws.close();
          }
          state.shouldReconnect = true;
          if (state.reconnectTimer) {
            clearTimeout(state.reconnectTimer);
            state.reconnectTimer = null;
          }
          if (!isRetry) {
            transcriptEl.innerHTML = '';
            state.itemsByUnit.clear();
            state.queue = [];
            state.playing = null;
            nowPlayingEl.textContent = 'Nothing queued.';
            setQueueStats('‚Äî');
          }
          setStatus('Connecting‚Ä¶');

          const protocol = location.protocol === 'https:' ? 'wss' : 'ws';
          const wsUrl = `${protocol}://${location.host}/ws?room=${encodeURIComponent(
            state.roomId
          )}&role=listener&lang=${encodeURIComponent(state.lang)}&tts=${state.wantsTts}`;
          const socket = new WebSocket(wsUrl);

          socket.onopen = () => {
            setStatus('Connected');
            const queued = state.queue.length + (state.playing ? 1 : 0);
            setQueueStats(queued ? `${queued} item(s) queued` : 'Queue empty');
            if (state.reconnectTimer) {
              clearTimeout(state.reconnectTimer);
              state.reconnectTimer = null;
            }
            if (state.itemsByUnit.size) {
              const versions = {};
              state.itemsByUnit.forEach((value, key) => {
                versions[key] = value.version;
              });
              try {
                socket.send(
                  JSON.stringify({ type: 'resume', payload: { versions, lang: state.lang } })
                );
              } catch (err) {
                console.warn('Failed to send resume payload', err);
              }
            }
          };
          socket.onclose = () => {
            state.ws = null;
            if (state.shouldReconnect) {
              setQueueStats('Reconnecting‚Ä¶');
              scheduleReconnect();
            } else {
              setQueueStats('‚Äî');
              setStatus('Disconnected');
            }
          };
          socket.onerror = () => {
            setStatus('Error');
            scheduleReconnect();
          };
          socket.onmessage = (event) => {
            try {
              const message = JSON.parse(event.data);
              if (message.type === 'patch') {
                renderPatch(message.payload);
              } else if (message.type === 'tts') {
                enqueueTts(message.payload);
              } else if (message.type === 'hello') {
                console.debug('Hello', message.payload);
              } else if (message.type === 'reset') {
                state.itemsByUnit.clear();
                state.queue = [];
                if (state.playing) {
                  state.playing.audio.pause();
                  state.playing = null;
                }
                transcriptEl.innerHTML = '';
                nowPlayingEl.textContent = 'Nothing queued.';
                setQueueStats('Queue reset');
              }
            } catch (err) {
              console.warn('Failed to parse message', err);
            }
          };

          state.ws = socket;
          connectBtn.disabled = true;
          disconnectBtn.disabled = false;
        }

        function disconnect() {
          state.shouldReconnect = false;
          if (state.reconnectTimer) {
            clearTimeout(state.reconnectTimer);
            state.reconnectTimer = null;
          }
          if (state.ws) {
            state.ws.close(1000, 'Client disconnect');
            state.ws = null;
          }
          state.queue = [];
          state.playing = null;
          setQueueStats('‚Äî');
          nowPlayingEl.textContent = 'Nothing queued.';
          setStatus('Disconnected');
          connectBtn.disabled = false;
          disconnectBtn.disabled = true;
        }

        connectBtn.addEventListener('click', connect);
        disconnectBtn.addEventListener('click', disconnect);
        ttsToggle.addEventListener('change', () => {
          state.wantsTts = ttsToggle.checked;
          if (!state.wantsTts) {
            state.queue = [];
            if (state.playing) {
              state.playing.audio.pause();
              state.playing = null;
            }
            setQueueStats('TTS disabled');
            nowPlayingEl.textContent = 'TTS disabled.';
          }
        });

        window.addEventListener('beforeunload', disconnect);
      })();
    </script>
  </body>
</html>
